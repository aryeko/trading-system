# S-12: Observability and Artifact Manifest

**Last updated:** 2025-09-21

## Outcome
- Standardize logging across the pipeline and produce a manifest summarizing every artifact generated during a run (paths, hashes, sizes, durations).

## Deliverables
- Logging utilities that emit structured JSON (or key-value text) with step, symbol, and timing metadata.
- `manifest.json` per run capturing inputs/outputs, file hashes (SHA256), row counts, and execution timings.
- CLI command `ts observability manifest --run reports/2024-05-02` to display or validate the manifest.

## Functional Requirements
- Every CLI step (pull, preprocess, signals, etc.) must emit start/end log entries with durations and status.
- Manifest must include pointers to log files and upstream artifacts (e.g., raw vs curated directories).
- Provide a schema definition for the manifest and validate it as part of CI/golden tests.
- Support exporting logs to external systems (stdout structured logs ready for ingestion by ELK/Grafana Loki).

## CLI Additions
- `poetry run ts observability manifest --run <reports/YYYY-MM-DD>` prints a summary table and validates SHA hashes against actual files.
- `poetry run ts observability tail --run <reports/YYYY-MM-DD>` streams structured logs for that run.

## Verification
1. Execute a full pipeline run and confirm a `manifest.json` is produced alongside reports.
2. Run the manifest CLI command; verify file hashes match and mismatches trigger non-zero exit.
3. Ensure structured logs contain consistent keys across modules by inspecting `run.log`.
4. Add unit tests validating manifest serialization/deserialization and hash computation.

## Dependencies
- S-09 (CLI integration) and earlier pipeline steps for artifacts.

## Notes
- Manifest provides the backbone for auditability and for S-13 golden fixtures; treat it as a public contract.
